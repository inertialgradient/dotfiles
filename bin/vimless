#!/bin/bash

# Script to clean up text and pipe to nvim with custom pager config
# Usage: cat file.txt | vimless
# Or: vimless < file.txt

if [ -z "${XDG_CONFIG_HOME}" ]; then
  echo "Error: ${XDG_CONFIG_HOME} not set in $0"
  exit 1
fi

# Set the custom vimrc path
VIMRC_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/vim/vimrc.pager.vim"

if [ ! -f "${VIMRC_PATH}" ]; then
  echo "Error: ${VIMRC_PATH} not found"
  exit 1
fi

strip_trailing_empty_lines() {
  awk -v debug=0 -v pattern="" '
    BEGIN {
      if (debug) print "DEBUG: Starting processing" > "/dev/stderr"
    }
    {
      # Store all lines in an array
      lines[NR] = $0
      if (debug) print "DEBUG: Line " NR ": \"" $0 "\"" > "/dev/stderr"
    }
    END {
      if (NR == 0) {
        if (debug) print "DEBUG: Input is empty, exiting" > "/dev/stderr"
        exit
      }
      # Find the last non-empty line (considering whitespace-only as empty)
      for (i = NR; i > 0; i--) {
        if (lines[i] ~ /^[[:space:]]*$/) {
          if (debug) print "DEBUG: Line " i " is empty or whitespace-only, skipping" > "/dev/stderr"
          continue
        }
        last = i
        if (debug) print "DEBUG: Found last non-empty line at " i > "/dev/stderr"
        break
      }
      if (last == 0) {
        if (debug) print "DEBUG: No non-empty lines found" > "/dev/stderr"
        exit
      }
      # Print lines up to the last non-empty, optionally filtering by pattern
      for (i = 1; i <= last; i++) {
        if (pattern == "" || lines[i] ~ pattern) {
          print lines[i]
          if (debug) print "DEBUG: Printed line " i ": \"" lines[i] "\"" > "/dev/stderr"
        } else if (debug) {
          print "DEBUG: Line " i " skipped due to pattern mismatch" > "/dev/stderr"
        }
      }
    }'
}

sed -E 's/^[[:space:]]*[0-9]+[[:space:]]+//g' | # strip leading line numbers
  sed 's/[[:space:]]*$//' |                       # strip trailing whitespace
  strip_trailing_empty_lines |
  nvim -u "$VIMRC_PATH" -c 'normal Gzz' -
