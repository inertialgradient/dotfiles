" ----------------- Base Settings ------------------------
set nocompatible
filetype plugin indent on
scriptencoding utf-8
set fileencodings=utf-8

" Suppress 'Pattern not found' messages
set shortmess+=c

" add fzf to rtp
set runtimepath+=~/.fzf

" Disable italics
let g:solarized_italic = 0

" ----------------- Load Plugins ------------------------
call plug#begin('~/.vim/plugged')
  source $HOME/.vim/manifest.vim
call plug#end()

"-------------------------------------------------------------
" Python interpreters
"-------------------------------------------------------------
let g:python_host_prog = '/Users/jkrmr/.anaconda3/envs/neovim2/bin/python'
let g:python3_host_prog = '/Users/jkrmr/.anaconda3/envs/neovim3/bin/python'

"-------------------------------------------------------------
" Fix for YankRing bug
"-------------------------------------------------------------
let g:yankring_clipboard_monitor=0

"--------------------------------------------------------------
" netrw
"--------------------------------------------------------------
let g:netrw_liststyle = 4   " 4 lightweight, 3 tree
let g:netrw_preview   = 1   " open previews in vertical split (p)
let g:netrw_winsize   = 70  " give previewed windows 70% of screen width
let g:netrw_banner    = 0

"--------------------------------------------------------------
" Vim Session: session autosave
"--------------------------------------------------------------
let g:session_default_overwrite = 1
let g:session_autosave = 'no'

"--------------------------------------------------------------
" Rainbow parentheses
"--------------------------------------------------------------
augroup rainbow_parentheses
  autocmd!

  autocmd VimEnter * RainbowParenthesesToggle
  autocmd Syntax * RainbowParenthesesLoadRound
  autocmd Syntax * RainbowParenthesesLoadSquare
  autocmd Syntax * RainbowParenthesesLoadBraces
augroup END

"-------------------------------------------------------------
" Restore position
"-------------------------------------------------------------
augroup vimrcEx
  autocmd!

  " When editing a file, always jump to the last known cursor position.
  " Don't do it for commit messages, when the position is invalid, or when
  " inside an event handler (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  " automatically re-balance the visible splits as tmux panes are created,
  " destroyed, or resized or window resized
  autocmd VimResized * :wincmd =
augroup END

"-------------------------------------------------------------
" Colors
"-------------------------------------------------------------
" Base vim settings
set t_Co=256  " 256 color terminal

" Allow italic text in vim
set t_ZH=[3m
set t_ZR=[23m

" Color scheme settings
if !has("gui_running")
  let g:solarized_termcolors=16
endif

set background=dark
colorscheme solarized

"--------------------------------------------------------------
" Line numbering
"--------------------------------------------------------------
set numberwidth=1
set relativenumber
set number

" Toggle relative and absolute numbering
function! NumberToggle()
  if &relativenumber == 1
    set norelativenumber
    set number
  else
    set relativenumber
    set number
  endif
endfunction

"--------------------------------------------------------------
" Folding
"--------------------------------------------------------------
" Enable folding based on indentation (faster than syntax)
set foldmethod=syntax

" Initial fold only 1 level deep
set foldlevelstart=1

" Custom folding function
if has('folding')
  set foldtext=MyFoldText()

  function! MyFoldText()
    if v:version < 701
      return foldtext()
    endif

    " clear fold from fillchars to set it up the way we want later
    let &l:fillchars = substitute(&l:fillchars,',\?fold:.','','gi')
    let l:numwidth = (v:version < 701 ? 8 : &numberwidth)

    if b:foldpat == 1
      let l:align = winwidth(0)-&foldcolumn-(&nu ? Max(strlen(line('$'))+1, l:numwidth) : 0)
      let l:foldtext = ' '.v:folddashes
      let l:linetext = substitute(getline(v:foldstart),'\s\+$','','')
      let l:linetext .= ' ---'.(v:foldend-v:foldstart-1).' lines--- '
      let l:linetext .= substitute(getline(v:foldend),'^\s\+','','')
      let l:linetext = strpart(l:linetext,0,l:align-strlen(l:foldtext))
      let l:align -= strlen(l:linetext)
      setlocal fillchars+=fold:-
      return printf('%s%*s', l:linetext, l:align, l:foldtext)
    endif

    if &fdm == 'diff'
      let l:foldtext = ' '.(v:foldend-v:foldstart).' lines the same -------'.v:folddashes.'|'
    elseif !exists('b:foldpat') || b:foldpat==0
      let l:foldtext = ' '.(v:foldend-v:foldstart).' lines '.v:folddashes.'|'
    endif

    let l:endofline = (&textwidth>0 ? &textwidth : 80)
    let l:linetext = strpart(getline(v:foldstart),0,l:endofline-strlen(l:foldtext))
    let l:align = l:endofline-strlen(l:linetext)
    return printf('%s%*s', l:linetext, l:align, l:foldtext)
  endfunction
endif

"--------------------------------------------------------------
" Navigation / Window Management
"--------------------------------------------------------------
" Open new split panes to right and bottom
set splitbelow
set splitright

" --- window resizing ---
nnoremap <Left>  <C-w><
nnoremap <Right> <C-w>>
nnoremap <Down>  <C-w>+
nnoremap <Up>    <C-w>-

" --- buffer navigation ---
" C-e: Scroll window up by 5 lines
nnoremap <C-e> 5<C-e>

" C-y: Scroll window down by 5 lines
nnoremap <C-y> 5<C-y>

" --- tab navigation ---
" S-h: previous tab
nnoremap <S-h> gT

" S-l: next tab
nnoremap <S-l> gt

"--------------------------------------------------------------
" General Settings
"--------------------------------------------------------------
let g:mapleader = ' ' " use space as leader key

set history=50    " 50 items in command history
set ruler         " show the cursor position all the time
set showcmd       " display incomplete commands
set laststatus=2  " Always display the status line
set autowrite     " Automatically :write before running commands
set lazyredraw    " Redraw for typed actions, not when executing macros
set ttyfast       " This is a fast terminal
set noshowmode    " don't show the current mode in the message bar
set autowrite     " Automatically :write before running commands

" Backup policy
set backup                   " keep backup files
set backupdir=~/.vim/backup/ " store backup files in ~/.vim/backup
set directory=~/.vim/tmp/    " store swap files in ~/.vim/tmp
set backupskip=/tmp/*,/private/tmp/*
set writebackup

" Backspace behavior
set backspace=indent,start " allow backspace over indent and start, not eol.

" Searching
set incsearch     " do incremental searching
set hlsearch      " highlight search matches by default
set ignorecase    " case insensitive pattern matching
set smartcase     " overrides ignorecase if pattern contains upcased chars
let @/ = ''       " clear the search register
:nohlsearch       " clear any previously highlighted search matches

" Use Rg for grepping
" set grepprg=ag\ --numbers\ --column\ --nocolor\ --noheading\ --nogroup\ --nobreak\ --case
set grepprg=rg\ --column\ --no-heading
set grepformat=%f:%l:%c:%m

" Indentation with soft tabs, 2 spaces
set expandtab      " use soft tabs
set shiftwidth=2   " spaces per tab (when shifting)
set softtabstop=2  " 2-space soft tabs
set shiftround     " always indent by multiple of shiftwidth

" Call out extra whitespace
set list listchars=tab:Â»Â·,trail:Â·,nbsp:Â·

" Command mode autocompletion settings
set wildmode=list:longest,list:full

" Make message bar taller to avoid 'press enter' prompt
set cmdheight=2

" Use all abbreviations in shortmessage
set shortmess+=a

" don't give the intro message when starting Vim
set shortmess+=I

" Window size shifts on focus, current screen stays larger
set winwidth=84
set winheight=5
set winminheight=5
set winheight=999

" Make it obvious where 80 characters is
set textwidth=80
set colorcolumn=+0

" keep context lines you would like to see above and below the cursor
set scrolloff=10

" Always use vertical diffs
set diffopt+=vertical

" set esckeys  " will break any sequences using escape in insert mode
set timeoutlen=500 ttimeoutlen=10

" Preserve words when breaking lines
set linebreak

" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &runtimepath) ==# ''
  runtime! macros/matchit.vim
endif

"--------------------------------------------------------------
" Convenience Bindings
"--------------------------------------------------------------
" <CR>: turn off highlighting by pressing enter
nnoremap <silent><CR> :noh<CR><CR>

" \: (backward slash) to grep-with-ag-to-quickfix shortcut
command! -nargs=+ -complete=file -bar Rg silent! grep! <args>|cwindow|redraw!
nnoremap <leader>/ :Rg ''<LEFT>

" K: Grep for the word under the cursor or visual selection,
"    open results in quickfix pane
nnoremap <silent><S-k> yiw:grep! "<C-R>0"<CR>:cw<CR>
vnoremap <silent><S-k> y:grep! "<C-R>0"<CR>:cw<CR>

" -------------- Leader key mappings (ctrl) -----------------
" C-]: Open ctag in a vertical split
map <silent><leader><C-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

" ]: Open ctag in a horizontal split
map <silent><leader>] :sp <CR>:exec("tag ".expand("<cword>"))<CR>

" ------------------- Leader key mappings ---------------------
" -: zoom the current vim pane
nnoremap <leader>- :wincmd _<CR>:wincmd \|<CR>

" =: re-balance vim pane sizes
nnoremap <leader>= :wincmd =<CR>

" ff: Invoke fzf
nnoremap <silent><leader>ff :FZF<CR>
nnoremap <silent><leader>pf :FZF<CR>

" fs: save buffer
nnoremap <silent><leader>fs :StripWhitespace<CR>:w<CR>

" g: Git
nnoremap <leader>g :Git<SPACE>

if has('nvim')
  " m: (make) run Neomake. Use [l and ]l to cycle through loc list
  nnoremap <leader>m :Neomake<CR>
endif

" R: From visual mode, leader+R populates command line for search and replace
vnoremap <leader>R y:%s/<C-R>"//g<LEFT><LEFT>

" R: From normal mode, redraws
nnoremap <leader>R :redraw!<CR>

" os: Open Session
nnoremap <leader>os :OpenSession<SPACE>

" wv: open vertical split
nnoremap <leader>wv <C-w>v

" ws: open split
nnoremap <leader>ws <C-w>s

" wh: navigate pane left
nnoremap <leader>wh <C-w>h

" wj: navigate pane down
nnoremap <leader>wj <C-w>j

" wk: navigate pane up
nnoremap <leader>wk <C-w>k

" wl: navigate pane right
nnoremap <leader>wl <C-w>l

" wq: close window
nnoremap <leader>wq :quit<CR>
nnoremap <leader>wd :x<CR>

" ss: Save Session
nnoremap <leader>ss :SaveSession<SPACE>

" x: cut visual selection to system clipboard
vnoremap <leader>x "*d

" v: paste from system clipboard
nnoremap <leader>v :set paste<CR>i<ESC>"*p:set nopaste<CR>
vnoremap <leader>v d:set paste<CR>i<ESC>"*p:set nopaste<CR>

"--------------------------------------------------------------
" Buffer-select utility commands
"--------------------------------------------------------------
function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:bufopen(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

" fuzzy-select from buffer list
nnoremap <silent> <leader>bb :call fzf#run({
\   'source':  reverse(<sid>buflist()),
\   'sink':    function('<sid>bufopen'),
\   'options': '+m',
\   'down':    len(<sid>buflist()) + 2
\ })<CR>

"--------------------------------------------------------------
" Reload all open buffers
"--------------------------------------------------------------
function! ReloadAllBuffers ()
  set autoread
  checktime
  echo 'Buffers reloaded'
endfunction

command! RA :call ReloadAllBuffers()

"--------------------------------------------------------------
" vim-test
"--------------------------------------------------------------
" (loaded /after because it doesn't work in the normal place,
" because reasons)
" ----------------------------------------------------------------------------
nnoremap <leader>s :w<CR>:TestNearest<CR>
nnoremap <leader>S :w<CR>:TestFile<CR>
nnoremap <leader>A :wa<CR>:TestSuite<CR>
nnoremap <leader>l :w<CR>:TestLast<CR>
nnoremap <leader>g :w<CR>:TestVisit<CR>

" default test strategy is vimux
let g:test#strategy = 'vimux'

"--------------------------------------------------------------
" Vimux
"--------------------------------------------------------------
" zoom the tmux runner page
nnoremap <silent><leader>fr :VimuxZoomRunner<CR>
nnoremap <silent><leader>rc :VimuxRunCommand<SPACE>
nnoremap <silent><leader>r :VimuxRunLastCommand<CR>

"--------------------------------------------------------------
" yank-as-code-block
"--------------------------------------------------------------
" TODO
" - Consolidate variables
" - Consolidate git invocations (if git [gh/glab/bb], elsif hg [bb], else)
" - language-specific commenting
" - VCS-agnostic
" - Optionally omit links / configure format
" - Yank folded:
"    <details>
"    <summary><a href="https://github.com/jkrmr/dot_spacemacs/blob/498e45c8/init.el#L16-L23">init.el#L16-L23 (498e45c8)</a></summary>
"
"    ```el
"    ;; init.el L16-L23 (498e45c8)
"
"         (auto-completion :variables
"                          auto-completion-return-key-behavior nil
"                          auto-completion-tab-key-behavior 'complete
"                          auto-completion-complete-with-key-sequence nil
"                          auto-completion-complete-with-key-sequence-delay 0.1
"                          auto-completion-private-snippets-directory nil
"                          auto-completion-enable-snippets-in-popup t
"                          auto-completion-enable-help-tooltip t)
"    ```
"    </details>
"
function! s:CommentedLine(line)
  echo &filetype
  if &filetype =~# 'html\|eruby'
    return '<!-- ' . a:line . ' -->'
  elseif &filetype =~# 'lisp\|clojure'
    return ';; ' . a:line
  elseif &filetype =~# 'tex'
    return '% ' . a:line
  elseif &filetype =~# 'python\|ruby\|sh\|desktop\|fstab\|conf\|profile\|bash\|yaml'
    return '# ' . a:line
  elseif &filetype =~# 'lua'
    return '-- ' . a:line
  elseif &filetype =~# 'vim'
    return '" ' . a:line
  else
    return '// ' . a:line
  endif
endfunction

function! s:CurrentVCSCommit(target_dir, sha)
  if a:sha =~# 'fatal'
    return ''
  else
    return ' (' . a:sha[0:8] . ')'
  endif
endfunction

function! s:PathFromProjectRoot(full_path, project_root, target_dir, home_dir)
  if a:project_root =~# 'fatal'
    return substitute(a:full_path, a:home_dir, '~', '')
  else
    return substitute(a:full_path, a:project_root . '/', '', '')
  endif
endfunction

function! s:CurrentVCSRemote(target_dir, commit, filepath, filename, startline, endline)
  let l:git_result = system('cd ' . a:target_dir . " && git remote -v | awk '/fetch/{print $2}' | sed -Ee 's#(git@|git://)#http://#' -e 's@com:@com/@' -e 's/\.git$//'")
  let l:remote = substitute(l:git_result, '\n\+$', '', '')

  if l:remote =~# 'http'
    if l:remote =~# 'github|gitlab'
      return l:remote . '/blob/' . a:commit . '/' . a:filepath . '#L' . a:startline . '-L' . a:endline
    elseif l:remote =~# 'bitbucket'
      return l:remote . '/src/' . a:commit . '/' . a:filepath . '#' . a:filename . '-' . a:startline . '-' . a:endline
    else
      return l:remote . '/blob/' . a:commit . '/' . a:filepath . '#L' . a:startline . '-L' . a:endline
    endif
  end
endfunction

function! s:FormattedLineNummbers(line1, line2)
  if a:line1 ==# a:line2
    return 'L' . a:line1
  else
    return 'L' . a:line1 . '-L' . a:line2
  endif
endfunction

function! s:RemoteMarkdownLink(remote_url)
  if a:remote_url ==# '0'
    return ''
  else
    return '<sup>[[source](' . a:remote_url . ')]</sup>'
  endif
endfunction

function! s:YankAsMarkdown(line1, line2)
  let l:save_cursor = getpos('.')

  let l:home_dir = substitute(system('echo $HOME'), '\n\+$', '', '')
  let l:full_path = expand('%:p')
  let l:filename = expand('%:t')

  let l:target_directory = substitute(l:full_path, l:filename, '', '')
  let l:project_root = substitute(system('cd ' . l:target_directory . ' && git rev-parse --show-toplevel'), '\n\+$', '', '')
  let l:sha = substitute(system('cd ' . l:target_directory . ' && git rev-parse --short HEAD'), '\n\+$', '', '')

  let l:commit = s:CurrentVCSCommit(l:target_directory, l:sha)
  let l:short_path = s:PathFromProjectRoot(l:full_path, l:project_root, l:target_directory, l:home_dir)
  let l:line_numbers = s:FormattedLineNummbers(a:line1, a:line2)
  let l:remote = s:CurrentVCSRemote(l:target_directory, l:sha, l:short_path, l:filename, a:line1, a:line2)
  let l:remote_link = s:RemoteMarkdownLink(l:remote)

  let l:source_comment = l:short_path . ' ' . l:line_numbers . l:commit
  let l:comment_leader = s:CommentedLine(l:source_comment)

  let l:lines = getline(a:line1, a:line2)
  let l:markdown = [ '```' . &filetype, l:comment_leader . "\n" ]
        \ + l:lines
        \ + ['```', l:remote_link]

  let l:snippet = join(l:markdown, "\n")
  let @* = l:snippet
  call setpos('.', l:save_cursor)
endfunction

command! -range=% YankAsMarkdown call <SID>YankAsMarkdown(<line1>, <line2>)
vnoremap <silent> gym :YankAsMarkdown<CR>

"--------------------------------------------------------------
" Plugins
"--------------------------------------------------------------
" Completion trigger configuration.
let g:UltiSnipsExpandTrigger       = '<Tab>'
let g:UltiSnipsListSnippets        = '<C-Tab>'
let g:UltiSnipsJumpForwardTrigger  = '<Tab>'
let g:UltiSnipsJumpBackwardTrigger = '<S-Tab>'
let g:UltiSnipsEditSplit           = 'context'

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit='vertical'

" YankRing
" YankRing: location of history file
let g:yankring_history_dir = '~/.vim/tmp'

" YankRing: Cycle through the yank register
let g:yankring_replace_n_pkey = '<C-k>'
let g:yankring_replace_n_nkey = '<C-j>'
nnoremap <silent><leader>p :YRShow<CR>

" AutoPairs: disable closed-pair jumping instead of inserting
let g:AutoPairsFlyMode = 0
let g:AutoPairsShortcutBackInsert = '<C-b>'

function! IsEmptyPair(str)
  for pair in split(&matchpairs, ',') + [ "''", '""', '``' ]
    if a:str == join(split(pair, ':'),'')
      return 1
    endif
  endfor

  return 0
endfunc

function! SkipDelim(char)
  let cur = strpart(getline('.'), col('.')-2, 3)

  if cur[0] == "\\"
    return a:char
  elseif cur[1] == a:char
    return "\<Right>"
  elseif cur[1] == ' ' && cur[2] == a:char
    return "\<Right>\<Right>"
  elseif IsEmptyPair(cur[0] . a:char)
    return a:char . "\<Left>"
  else
    return a:char
  endif
endfunc

inoremap <expr> ) SkipDelim(')')
inoremap <expr> ] SkipDelim(']')
inoremap <expr> } SkipDelim('}')
inoremap <expr> ' SkipDelim("'")
inoremap <expr> " SkipDelim('"')
inoremap <expr> ` SkipDelim('`')

let g:deoplete#enable_at_startup = 1

" Dependencies
"   npm install -g elm elm-test elm-oracle
"
" <leader> m  Compile the current buffer.
" <leader> b  Compile the Main.elm file in the project.
" <leader> t  Runs the tests of the current buffer.
" <leader> r  Opens an elm repl in a subprocess.
" <leader> e  Shows the detail of the current error or warning.
" <leader> d  Shows the type and docs for the word under the cursor.
" <leader> w  Opens the docs web page for the word under the cursor.

" Elm format
let g:elm_format_autosave = 1


" Disable by default
let g:user_emmet_install_global = 0

"enable for html, css, erb, scss
augroup emmetVim
  autocmd!
  autocmd FileType html,css,eruby,scss EmmetInstall
augroup END

" let g:user_emmet_leader_key='<C-y>'

" Use bars for indents
let g:indentLine_char = 'â'

" Disable indent guides by default
let g:indentLine_enabled = 0

let g:used_javascript_libs = 'jquery,underscore,react,flux,requirejs'

let g:lightline = {
      \   'colorscheme': 'solarized',
      \   'active': {
      \     'left': [
      \       [ 'mode', 'paste' ],
      \       [ 'fugitive', 'filename' ]
      \     ],
      \     'right': [
      \       [ 'syntastic', 'lineinfo' ],
      \       [ 'percent' ],
      \       [ 'fileformat', 'fileencoding', 'filetype' ]
      \     ]
      \   },
      \   'component_function': {
      \     'mode':         'LLMode',
      \     'fugitive':     'LLFugitive',
      \     'filename':     'LLFilename',
      \     'readonly':     'LLReadonly',
      \     'modified':     'LLModified',
      \     'fileformat':   'LLFileFormat',
      \     'fileencoding': 'LLFileEncoding',
      \     'filetype':     'LLFileType'
      \   },
      \   'component_expand': {
      \     'syntastic': 'SyntasticStatuslineFlag'
      \   },
      \   'component_type': {
      \     'syntastic': 'error'
      \   },
      \   'subseparator': {
      \     'left': '|', 'right': '|'
      \   }
      \ }

function! LLMode()
  let fname = expand('%:t')
  return  fname == '__Gundo__'  ? 'Gundo'  :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ winwidth(0) < 60 ? '' :
        \ lightline#mode() == 'NORMAL'  ? 'N'  :
        \ lightline#mode() == 'INSERT'  ? 'I'  :
        \ lightline#mode() == 'VISUAL'  ? 'V'  :
        \ lightline#mode() == 'V-LINE'  ? 'VL' :
        \ lightline#mode() == 'V-BLOCK' ? 'VB' :
        \ lightline#mode() == 'REPLACE' ? 'R'  : lightline#mode()
endfunction

function! LLModified()
  return &modified ? '+' : ''
endfunction

function! LLReadonly()
  return &readonly ? 'î¢' : ''
endfunction

function! LLFugitive()
  if !exists('*fugitive#head')
    return ''
  endif

  let head = fugitive#head()
  return strlen(head) ? 'î  ' .head : ''
endfunction

function! LLFilename()
  let fname = expand('%:t')
  return  fname == '__Tagbar__' ? g:lightline.fname :
        \ fname == '__Scratch__' ? 'Scratch' :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite'    ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != LLReadonly() ? LLReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LLModified() ? ' ' . LLModified() : '')
endfunction

function! LLFileEncoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! LLFileFormat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LLFileType()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'file') : ''
endfunction


if has('nvim')
  autocmd! BufWritePost * Neomake
endif

let g:neomake_coffee_enabled_makers     = ['coffeelint']
let g:neomake_css_enabled_makers        = ['csslint']
let g:neomake_elixir_enabled_makers     = ['credo']
let g:neomake_go_enabled_makers         = ['golint']
let g:neomake_haml_enabled_makers       = ['haml-lint']
let g:neomake_javascript_enabled_makers = ['eslint']
let g:neomake_json_enabled_makers       = ['jsonlint']
let g:neomake_jsx_enabled_makers        = ['eslint']
let g:neomake_markdown_enabled_makers   = ['mdl']
let g:neomake_python_enabled_makers     = ['pep8']
let g:neomake_ruby_enabled_makers       = ['rubocop']
let g:neomake_sh_enabled_makers         = ['shellcheck']
let g:neomake_vim_enabled_makers        = ['vint']
let g:neomake_yaml_enabled_makers       = ['yamllint']
let g:neomake_haml_enabled_makers       = ['hamllint']

let g:better_whitespace_filetypes_blacklist=['qf']

" HugeFile: disable options for large files (>= 1MB)
let g:hugefile_trigger_size = 1

" Allow prompt for interactive input.
let g:jsdoc_allow_input_prompt = 1

" Prompt for a function description
let g:jsdoc_input_description = 0

" Prompt for a value for @name, add it to the JSDoc
" block comment along with the @function tag.
let g:jsdoc_additional_descriptions = 0

" Add the @return tag.
let g:jsdoc_return = 1

" Prompt for and add a type for the aforementioned @return tag.
let g:jsdoc_return_type = 1

" Prompt for and add a description for the @return tag.
let g:jsdoc_return_description = 1

" Set value to 0 to turn off default mapping of <C-l> :JsDoc<cr>
let g:jsdoc_default_mapping = 0

" Set value to 1 to turn on access tags like @access <private|public>.
" Set value to 2 to turn on access tags like @<private|public>
let g:jsdoc_access_descriptions = 2

" Set value to 1 to turn on detecting underscore
" starting functions as private convention
let g:jsdoc_underscore_private = 1

" Set value to 1 to allow ECMAScript6 shorthand syntax.
let g:jsdoc_allow_shorthand = 1

" Characters used to separate @param name and description.
let g:jsdoc_param_description_separator = ' : '

" Override default type and description. See help more detail.
let g:jsdoc_custom_args_hook = {}

" Allow JSX in normal JS files
let g:jsx_ext_required = 0

" Togglecursor: insert mode uses an underline
let g:togglecursor_insert = 'underline'

" YouCompleteMe: keybindings
set runtimepath+=~/.vim/plugged/YouCompleteMe
let g:ycm_key_list_select_completion = ['<C-j>']
let g:ycm_key_list_previous_completion = ['<C-k>']
let g:ycm_key_invoke_completion = ''
let g:ycm_min_num_of_chars_for_completion = 0

" ---------------- Overrides  --------------------------
if filereadable(expand('~/.vimrc.local'))
  source $HOME/.vimrc.local
endif
