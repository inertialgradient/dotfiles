#!/usr/bin/env ruby

# Generates a changelog in markdown format, for PRs since the given date (passed
# as a command-line argument).
#
# Example:
#
# ```
# Changelog
# =========
# (generated 2014.11.06)
#
# Features
# --------
#
# **[PR #1][PR #1]: Implement a killer feature ([TX-34][TX-34])**
#
# [PR #1]: <PR url>
# [TX-34]: <ticket url>
#
# Bugfixes
# --------
#
# **[PR #196][PR #196]: Fix bug in file.cpp ([TX-35][TX-35])**
#
# [PR #196]: <PR url>
# [TX-35]: <ticket url>
# ```
# etc.

module Changelog
  def self.from_git_log_since(start_date)
    changelog = ChangelogWriter.new(date_flag: start_date)
    changelog.generate
  end

  class ChangelogWriter
    TODAY = Time.now.localtime.strftime("%Y.%m.%d")

    attr_accessor :date_flag, :entries, :account_name, :repo_name

    def initialize(date_flag:)
      self.date_flag = date_flag
    end

    def generate
      get_all_pr_merge_commits
      get_repo_info
      sort_commits
      group_commits_by_type
      write_to_file
      prompt_user
    end

    private

    def get_all_pr_merge_commits
      self.entries = Dir.chdir(Dir.pwd) do
        `git log --oneline --color=never #{date_flag}\
          --merges \
          -E --grep='Merge pull request #[[:digit:]]\+ from'`.split("\n")
      end
    end

    def get_repo_info
      self.account_name, self.repo_name = parse_origin_from_remotes_listing
    end

    def parse_origin_from_remotes_listing
      Dir.chdir(Dir.pwd) do
        `git remote -v | grep origin | head -1 |\
          sed -E 's@.+:(.+)/(.+)\.git.*@\\1 \\2@'`.split
      end
    end

    def sort_commits
      self.entries = entries.map do |entry|
        ChangelogEntry.new(entry: entry, accnt: account_name, repo: repo_name)
      end.sort
    end

    def group_commits_by_type
      self.entries = entries.group_by(&:type)
    end

    def write_to_file
      File.open(output_file, "w") { |file| write_markdown_to(file, entries) }
    end

    def output_file
      "#{Dir.home}/Desktop/#{repo_name}.changelog-#{TODAY}.md"
    end

    def write_markdown_to(file, entries_by_type)
      title = "#{repo_name} Changelog"
      file.puts title, "=" * title.length, "(generated #{TODAY})\n"

      entries_by_type.each_pair do |type, entries|
        file.puts "\n#{type}", "#{'-' * type.length}\n\n", entries.join("\n")
      end
    end

    def prompt_user
      puts "Changelog saved to #{output_file}"
    end
  end

  # ChangelogEntry instances are comparable by PR number
  class ChangelogEntry
    include Comparable

    MERGE_PR_REGEX = %r{           # Example:
      (?<sha>[0-9a-f]{7})          #   1f88e62
      .+                           #   Merge pull request
      \#(?<pr_num>[[:digit:]]+)    #   #579
      \sfrom\s                     #    from
      [[:alnum:]]+\/               #   Vive/
      (?<branch>[\w\-\d\/]+)       #   gigster/f/membership-gifting
    }xi

    def initialize(entry:, accnt:, repo:)
      matches = entry.match(MERGE_PR_REGEX)
      @sha = matches[:sha]
      @pr = matches[:pr_num]
      @branch = matches[:branch]
      @accnt = accnt
      @repo = repo
      @description = ChangelogEntryDescription.new(@sha)
    rescue NoMethodError => e
      puts "#{e}: failed on #{log_entry_line}"
    end

    def base_url(kind)
      case kind
      when :commit then "http://github.com/#{@accnt}/#{@repo}/commit"
      when :pr     then "http://github.com/#{@accnt}/#{@repo}/pull"
      end
    end

    def commit(format = :short)
      case format
      when :full then @sha
      when :url  then "#{base_url(:commit)}/#{@sha}"
      else @sha[0, 5]
      end
    end

    def pr(format = :string)
      case format
      when :num then @pr.to_i
      when :url then "#{base_url(:pr)}/#{@pr}"
      else "PR ##{@pr}"
      end
    end

    def type
      case @type
      when /(?:e|ion|or)$/i then "#{@type.capitalize}s"
      when /(?:ix)$/i       then "#{@type.capitalize}es"
      when /y$/i            then "#{@type.capitalize}ies"
      else "Features"
      end
    end

    private

    def <=>(other)
      pr(:num) <=> other.pr(:num)
    end

    def to_s
      [
        "**[#{pr}][#{pr}]: #{@description}**",
        "[#{pr}]: #{pr(:url)}\n"
      ].join("\n")
    end
  end

  # Parses a merge commit's merge commit message for its descriptive content.
  class ChangelogEntryDescription
    # Regex constants used to parse branch names that follow our pattern of
    #   category/ticket_label-ticket_category (e.g. bugfix/TRAV-292)
    # Used in parse_content_from(description)
    TICKET_NUM      = /\w{2,4}[\s\-]?\d{2,3}\s*:?\s*/i
    TYPES           = /(Feature|Hotfix|Bugfix|Release|Refactor|Optimization)/i
    TYPE_AND_TICKET = %r{#{TYPES.source}\/#{TICKET_NUM.source}}i

    # Parses a given merge commit's details for a description of the changes
    # introduced by the merge.
    def initialize(sha_id)
      @full_description = parse_description_from_commit_message(sha_id)
      @description      = parse_content_from(@full_description)
    end

    private

    def begins_with_a_ticket_number?
      /^(#{TICKET_NUM.source}|#{TYPE_AND_TICKET.source})/
    end

    # Upcases the first letter of the merge commit's description,
    # held in @description (which is the merge commit's commit message, minus the
    # ticket number with which we prefix our pull requests.
    #
    # Examples:
    #   PR title: "TRAV-42: update Deals model tests."
    #   Merge commit message: "TRAV-42: update Deals model tests."
    #   @full_description: "TRAV-42: update Deals model tests."
    #   @description: "Update Deals model tests."
    #
    # @return [String] Capitalized description.
    def description_with_capitalized_first_letter
      @description.sub(/^(\w)/) { Regexp.last_match[1].upcase }
    end

    def only_a_ticket_number?
      /^(#{TICKET_NUM.source}|#{TYPE_AND_TICKET.source})$/
    end

    # Parses the merge commit's message for its descriptive content
    # Returns 'No description' when the commit message consists only of a
    # ticket number.
    # Defaults to the un-parsed commit message when it doesn't know what to do.
    # @return [String] descriptive content from merge commit message
    def parse_content_from(description)
      case description
      when only_a_ticket_number?
        "No description."
      when begins_with_a_ticket_number?
        ticket_number_from = Regexp.last_match[1]
        strip_leading ticket_number_from, description
      else
        description
      end
    end

    def parse_description_from_commit_message(sha_id)
      Dir.chdir(Dir.pwd) do
        `git show #{sha_id}`.split("\n").last.strip
      end
    end

    def strip_leading(ticket_number, description)
      description.sub(ticket_number, "")
    end

    def to_s
      description_with_capitalized_first_letter
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  date = ARGV.join(" ")
  date_flag = "--since='#{date}'" unless date.empty?
  Changelog.from_git_log_since(date_flag)
end
