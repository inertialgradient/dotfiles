#!/usr/bin/env bash
#-------------------------------------------------------------
# ALIASES: Editors, Tmux
#-------------------------------------------------------------
alias vi='nvim -u ~/.vim/minimal.vim'
alias vimplug='nvim +PlugInstall +PlugUpgrade +PlugUpdate +qall'
alias git=hub
alias dc='docker-compose'

#-------------------------------------------------------------
# ALIASES: FILE MANAGEMENT, SHELL NAVIGATION
#-------------------------------------------------------------
alias ..='\cd ..; l'     # go to parent dir and list contents
alias ...='\cd ../..; l' # go to grandparent dir and list contents
alias mkdir='mkdir -p'   # create subdirectories as necessary
alias h='history'        # show history
alias ls='gls'           # use GNU ls (emacs needs this)
alias l='gls --color'    # use GNU ls
alias la='l -A'          # list all files
alias ll='l -loh'        # show extended listing (but not all files)
alias llg='l -lh'        # show extended listing with group
alias lla='l -Aloh'      # all files, info, hide group, short sizes
alias llag='l -Al'       # all files, info, show group, short sizes
alias l.='l -d .*'       # show only files beginning with a dot
alias ll.='l -dloh .*'   # extended listing of files beginning with a dot
alias lt='tree'          # show directory as tree
alias d='dirs -v'        # show directory stack
alias c='clear'          # clear shell output
alias q='exit'           # quit the current process

#-------------------------------------------------------------
# ALIASES: SAFEGUARDS
#-------------------------------------------------------------
alias rm='rm -i'  # confirm deletion
alias mv='mv -i'  # confirm move if overwriting existing file
alias cp='cp -i'  # confirm copy if overwriting existing file
alias ln='ln -iv' # display error if link exists; link verbosely

#-------------------------------------------------------------
# ALIASES: MISC
#-------------------------------------------------------------
alias diff='colordiff'        # compare files, colorize output
alias hide='setfile -a V'     # hide a file
alias unhide='setfile -a v'   # unhide a file
alias npmls='npm ls -depth=0'
alias grep='GREP_COLOR="33;40" LANG=C grep --color=auto'
alias ssh='TERM=xterm-256color ssh'

#-------------------------------------------------------------
# ALIASES: Postfix
#-------------------------------------------------------------
alias -g G='| grep --line-number --context=1' # grep w/ context
alias -g C="| pbcopy" # copy to clipboard
alias -g P='| less'   # send to pager

#-------------------------------------------------------------
# SYNTAX HIGHLIGHTING
#-------------------------------------------------------------
# BSD
export CLICOLOR=1
export LSCOLORS=exfxcxdxbxegedabagacad

# GNU
export LS_COLORS="di=00;34:ex=00;31:ln=00;32:or=00;35:mi=90;30"

#-------------------------------------------------------------
# EDITOR / PAGER
#-------------------------------------------------------------
export EDITOR="nvim"
export PAGER="less"

# brew install [or sudo apt-get install] source-highlight
export LESS=' -r '
export LESSOPEN="| /usr/local/bin/src-hilite-lesspipe.sh %s"

# pager search matches coloring
export LESS_TERMCAP_so=$'\E[30;43m' # black on yellow
export LESS_TERMCAP_se=$'\E[00;00m' # reset

#-------------------------------------------------------------
# MISC ENV VARIABLES
#-------------------------------------------------------------
export HISTCONTROL=ignoreboth   # Ignore spaces and duplicates
export HISTIGNORE="??:&:pwd:cd*:h:..*:l:ll:ll?:q:c:l:g"

#-------------------------------------------------------------
# Use Ag for FZF instead of find
#-------------------------------------------------------------
export FZF_DEFAULT_COMMAND='ag -l -g ""'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_DEFAULT_OPTS='--multi --ansi'

#-------------------------------------------------------------
# FUNCTIONS
#-------------------------------------------------------------
# restart homebrewed postgres
function restart_postgres() {
  launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
}

# Display any processes listening on the given port
function listening_on_port() {
  lsof -wni tcp:$1
}

alias ec="emacsclient -nw"
alias mux="tmux new -t"

# Open the editor as appropriate
function e() {
  local editor=nvim

  if [ -z "$1" ]; then
    echo $editor .
    $editor .
  elif [ "$#" -gt 1 ]; then
    $editor -p $@
  else
    echo $editor "$1"
    $editor "$1"
  fi
}

# Fuzzy-select a file from git status to open in editor
function eg() {
  local file="$(git select-files)"

  if [[ ! -z "$file" ]]; then
    e $(echo "$file")
  fi
}

# Fuzzy-select a file from all those modified on the current git branch (up to
# origin/master) to open in editor
function egg() {
  local file="$(git branch-modified-files | fzf-tmux --reverse -d 20)"

  if [[ ! -z "$file" ]]; then
    e $(echo "$file")
  fi
}

# create dir $1 and cd into it, creating subdirectories as necessary
function md() {
  local directory_name=$(echo $@ | sed -e "s/\s/_/g")
  mkdir -p "$directory_name" && cd "$directory_name";
}

# pretty-print the command search path
function pp() {
  if [[ "$1" == 'path' ]]; then
    ruby -e 'puts `echo $PATH`.gsub(":", "\n")'
  elif [[ "$1" == 'manpath' ]]; then
    ruby -e 'puts `echo $MANPATH`.gsub(":", "\n")'
  elif [[ "$1" == 'cdpath' ]]; then
    ruby -e 'puts `echo $CDPATH`.gsub(":", "\n")'
  fi
}

# Mac-specific: show and hide hidden files
function hidden_files() {
  if [[ $1 != "hide" && $1 != "show" ]]; then
    echo "Usage: hidden_files [show|hide]"; return 1;
  fi
  if [[ $1 == "hide" ]]; then
    local view=false;
  elif [[ $1 == "show" ]]; then
    local view=true;
  fi
  defaults write com.apple.finder AppleShowAllFiles $view;
  killall Finder;
}

# wrap rm -rf with a guard prompt
function del() {
  echo "rm -rf $@"
  echo -n "rm: Permanently delete the selected files/directories? "
  echo -n "This cannot be undone. "
  read dir

  if [[ $dir =~ ^[yY](es)?$ ]]; then
    echo "Deleting: $@"
    rm -rf "$@"
  else
    echo "Canceling with no changes made."
  fi
}

function binstubs() {
  bundle install --binstubs .bundle/bin
  rbenv rehash
}

#-------------------------------------------------------------
# Git
#-------------------------------------------------------------
#-------------------------------------------------------------
# FUNCTIONS
#-------------------------------------------------------------
function clone() {
  git clone $1 $2         # git@github.com:user/repo_name.git
  repo=${1##*/}           # repo_name.git
  dir=${2:=${repo%.*}}    # repo_name unless $2 is provided
  cd $dir                 # cds into repo directory
}

# No arguments: `git status`
# With arguments: acts like `git`
function g() {
  if [[ $# > 0 ]]; then
    git $@
  else
    \git status -sb
  fi
}

#-------------------------------------------------------------
# COLORIZED GIT PROMPT
#-------------------------------------------------------------
function git_color() {
  local clean='working (directory|tree) clean'
  local ahead_of_remote="Your branch is ahead of"
  local applying_patch="Unmerged"

  if [[ $git_status =~ $clean ]]; then
    if [[ $git_status =~ $ahead_of_remote ]]; then
      echo -ne $(color yellow)
    else
      echo -ne $(color green)
    fi
  elif [[ $git_status =~ $applying_patch ]]; then
    echo -ne $(color violet)
  else
    echo -ne $(color red)
  fi
}

function git_branch() {
  local git_status="$(\git status 2> /dev/null)"
  local is_on_branch='^On branch ([^[:space:]]+)'
  local is_on_commit='HEAD detached at ([^[:space:]]+)'
  local is_rebasing="rebasing branch '([^[:space:]]+)' on '([^[:space:]]+)'"

  if [[ $git_status =~ $is_on_branch ]]; then
    local branch=${BASH_REMATCH[1]:-$match[1]} # bash/zsh portable
    if [[ $git_status =~ "Unmerged paths" ]]; then
      git_color && echo -n "merging into $branch "
    else
      git_color && echo -n "$branch "
    fi
  elif [[ $git_status =~ $is_on_commit ]]; then
    local commit=${BASH_REMATCH[1]:-$match[1]}
    git_color && echo -n "$commit "
  elif [[ $git_status =~ $is_rebasing ]]; then
    local branch=${BASH_REMATCH[1]:-$match[1]}
    local commit=${BASH_REMATCH[2]:-$match[2]}
    git_color && echo -n "rebasing $branch on $commit "
  fi
}

#-------------------------------------------------------------
# ZSH
#-------------------------------------------------------------
# ZSH GENERAL
#-------------------------------------------------------------
alias reload!="source ~/.zshrc"
setopt extendedglob # Enable extended globbing
unsetopt nomatch    # Allow [ or ] wherever you want
autoload -U zmv     # rename files like zmv '(*).txt' '$1.html'

#-------------------------------------------------------------
# COMMAND COMPLETION
#-------------------------------------------------------------
shared='/usr/local/share'
fpath=(
  $HOME/.zsh/completion
  $shared/zsh-completions
  $shared/zsh/site-functions
  $fpath
)

autoload -U compinit && compinit
source $shared/zsh/site-functions/_aws
source $shared/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

compdef git=hub
compdef g=git

#-------------------------------------------------------------
# DIRECTORY STACK  (see http://j.mp/1lOiWio)
#-------------------------------------------------------------
setopt autocd autopushd pushd_minus pushd_silent
setopt pushd_to_home cdable_vars pushd_ignore_dups
export DIRSTACKSIZE=10

#-------------------------------------------------------------
# HISTORY SETTINGS
#-------------------------------------------------------------
setopt hist_ignore_all_dups inc_append_history
export HISTFILE=$HOME/.zhistory
export HISTSIZE=4096
export SAVEHIST=4096

#-------------------------------------------------------------
# COMMAND-LINE AND HISTORY NAVIGATION
#-------------------------------------------------------------
bindkey -M viins '^a' beginning-of-line
bindkey -M viins '^e' end-of-line
bindkey -M viins '^b' backward-char
bindkey -M viins '^f' forward-char
bindkey -M viins '^d' delete-char

bindkey -M viins '^k' kill-line

# issue the command, but keep it at the prompt
bindkey -M viins '^y' accept-and-hold
bindkey -M viins '^o' push-line-or-edit

bindkey -M emacs '^y' accept-and-hold
bindkey -M emacs '^o' push-line-or-edit

# enable ctrl-p/n for history search
autoload -U history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey -M vicmd "^n" history-beginning-search-backward-end
bindkey -M vicmd "^p" history-beginning-search-forward-end
bindkey -M viins "^n" history-beginning-search-backward-end
bindkey -M viins "^p" history-beginning-search-forward-end

# ^t Invoke FZF file finder
bindkey '^t' fzf-file-widget

# bindkey "^[[3"  prefix-2     # ensure delete backwards deletes
bindkey "^[[3~" delete-char  # ensure delete forwards deletes

# Position cursor after ARG[0] (for argument/flag entry)
function after-first-word() {
  zle beginning-of-line
  zle forward-word
}
zle -N after-first-word
bindkey '^x' after-first-word

#-------------------------------------------------------------
# COMMAND-LINE HISTORY SEARCHING AND NAVIGATION
#-------------------------------------------------------------
bindkey -M viins '^r' history-incremental-search-backward
bindkey -M vicmd '^r' history-incremental-search-backward

autoload -U up-line-or-beginning-search
autoload -U down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search

bindkey '\e[A' up-line-or-beginning-search
bindkey '\e[B' down-line-or-beginning-search
bindkey -s '\eOA' '\e[A'
bindkey -s '\eOB' '\e[B'

bindkey -M viins '^p' up-line-or-beginning-search
bindkey -M vicmd '^p' up-line-or-beginning-search
bindkey -M viins '^n' down-line-or-beginning-search
bindkey -M vicmd '^n' down-line-or-beginning-search

# back-i-search begins with current word
setopt complete_in_word

#-------------------------------------------------------------
# COLORS
#-------------------------------------------------------------
autoload -U colors && colors

function color {
  if   [[ $1 == 'red'    ]]; then echo -n %{$fg_no_bold[red]%}
  elif [[ $1 == 'yellow' ]]; then echo -n %{$fg_no_bold[yellow]%}
  elif [[ $1 == 'green'  ]]; then echo -n %{$fg_no_bold[green]%}
  elif [[ $1 == 'violet' ]]; then echo -n %{$fg_no_bold[magenta]%}
  elif [[ $1 == 'blue'   ]]; then echo -n %{$fg_no_bold[blue]%}
  elif [[ $1 == 'white'  ]]; then echo -n %{$fg_no_bold[white]%}
  elif [[ $1 == 'reset'  ]]; then echo -n %{$reset_color%}
  fi
}

#-------------------------------------------------------------
# PROMPT WITH SHORT PWD, COLORIZED GIT INFO
#-------------------------------------------------------------
setopt prompt_subst       # enables command substitution

PS1=$'\n$(color blue)%c ' # basename of pwd after a newline
PS1+='$(git_branch)'      # current branch or commit name, with color
PS1+='$(color reset)%# '  # reset color, add %
export PS1

#-------------------------------------------------------------
# Use Vim mode in Zsh
#-------------------------------------------------------------

if [ -n "$INSIDE_EMACS" ]; then
  # set emacs keybindings
  bindkey -e
else
  # set vi keybindings
  bindkey -v

  # no lag after pressing ESC to enter normal mode
  export KEYTIMEOUT=1

  # RHS prompt
  # ----------
  # Don't display RHS prompts from previous lines
  setopt transient_rprompt

  vim_ins_mode='[insert]'
  vim_cmd_mode='[normal]'
  vim_mode=$vim_ins_mode

  function zle-keymap-select {
    vim_mode="${${KEYMAP/vicmd/${vim_cmd_mode}}/(main|viins)/${vim_ins_mode}}"
    zle reset-prompt
  }

  function zle-line-init {
    vim_mode=$vim_ins_mode
    zle reset-prompt
  }

  zle -N zle-keymap-select
  zle -N zle-line-init

  RPROMPT='$(color yellow)${vim_mode}$(color reset)'
  RPROMPT2='$(color yellow)${vim_mode}$(color reset)'
fi

#-------------------------------------------------------------
# UNDO (DISABLE ZSH DEFAULTS)
#-------------------------------------------------------------
disable r # disable zsh's r

. $HOME/.dotfiles/path.sh

[[ -f $HOME/.fzf.zsh ]] && \
    . $HOME/.fzf.zsh

[[ -f $HOME/.anaconda/etc/profile.d/conda.sh ]] && \
    . $HOME/.anaconda/etc/profile.d/conda.sh

[[ -f $HOME/.zshrc.local ]] && \
    . $HOME/.zshrc.local
