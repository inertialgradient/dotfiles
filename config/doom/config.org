#+TITLE: Emacs Config

* Contents :TOC:
- [[#notes][Notes]]
- [[#general][General]]
  - [[#display][display]]
  - [[#leader-keys][leader keys]]
  - [[#super-keys][super keys]]
  - [[#file-paths][file paths]]
  - [[#identity][identity]]
- [[#diff-hl][diff-hl]]
- [[#dired][dired]]
- [[#evil][evil]]
  - [[#window-navigation][window navigation]]
  - [[#hybrid-evilemacs-keybindings][hybrid evil/emacs keybindings]]
  - [[#evil-cleverparens][evil-cleverparens]]
  - [[#evil-unimpaired][evil-unimpaired]]
  - [[#evil-matchit][evil-matchit]]
  - [[#evil-sort][evil-sort]]
  - [[#evil-text-objects][evil text objects]]
- [[#folding][folding]]
- [[#gtags][gtags]]
- [[#lookup][lookup]]
- [[#lsp][lsp]]
- [[#magit][magit]]
- [[#org][org]]
- [[#projectile][projectile]]
- [[#ruby][ruby]]
  - [[#evil-rails][evil-rails]]
  - [[#format-all][format-all]]
  - [[#ruby-factory][ruby-factory]]
  - [[#ruby-test][ruby-test]]
  - [[#projectile-rails][projectile-rails]]
  - [[#seeing-is-believing][seeing-is-believing]]
  - [[#toggle-breakpoint][toggle-breakpoint]]
- [[#smartparens][smartparens]]
- [[#time-tracking][time tracking]]
- [[#webkit][webkit]]
  - [[#browser-open-keybindings][browser-open keybindings]]
  - [[#browser-open-commands][browser-open commands]]
  - [[#browser-open-functions][browser-open functions]]
  - [[#xwidget-widget-keybindings][xwidget-widget keybindings]]
- [[#word-chars][word chars]]
- [[#workspaces][workspaces]]
- [[#yank-buffer-path-dwim][yank-buffer-path-dwim]]
- [[#yankee][yankee]]
- [[#yasnippet][yasnippet]]

* Notes

Useful functions/macros (see [[https://github.com/hlissner/doom-emacs/blob/develop/modules/lang/emacs-lisp/demos.org][API Demos]] for examples):

- =load!= for loading external *.el files relative to this one
- =use-package!= for configuring packages
- =after!= for running code after a package has loaded
- =add-load-path!= for adding directories to the =load-path=, relative to
  this file. Emacs searches the =load-path= when you load packages with
  =require= or =use-package=.
- =map!= for binding new keys

* General

** display

Doom exposes five (optional) variables for controlling fonts in Doom.
Here are the three important ones:

#+begin_src elisp
;; `doom-big-font' -- used for `doom-big-font-mode': use this for presentations / streaming
(setq doom-font (font-spec :family "SF Mono" :size 16 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "SF Mono" :size 16)
      doom-big-font (font-spec :family "SF Mono" :size 24))

(setq doom-theme 'doom-one)
(setq display-line-numbers-type 'relative)
(add-to-list 'initial-frame-alist '(fullscreen . maximized)) ;; Start maximized
#+end_src

** leader keys

Use =,= for the local leader key.

#+begin_src elisp
(setq doom-localleader-key ",")
#+end_src

** super keys

#+begin_src elisp
(map!
 "s-'" #'+vterm/toggle
 "s-K" #'kill-current-buffer
 "s-k" #'bury-buffer)
#+end_src

** file paths

File paths for Org documents, Deft notes, and etc.

#+begin_src elisp
(setq org-directory (concat (getenv "XDG_DATA_HOME") "/org"))
(setq deft-directory (concat org-directory "/notes"))
#+end_src

** identity

Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.

#+begin_src elisp
(setq user-full-name "Jake Romer"
      user-mail-address "jake@jmromer.org")
#+end_src

* diff-hl

Enable diff-highlight modes globally.

#+begin_src elisp
(after! diff-hl
  (global-diff-hl-mode))
#+end_src

#+begin_src elisp
(map!
 :n "[h" #'diff-hl-show-hunk-previous
 :n "]h" #'diff-hl-show-hunk-next)
#+End_src

Use a posframe for displaying hunks.

#+begin_src elisp
(after! diff-hl
  (setq diff-hl-show-hunk-function #'diff-hl-show-hunk-posframe))
#+end_src

Add refresh hooks for magit > 2.4.0.

#+begin_src elisp
(after! (:all diff-hl magit)
  (add-hook! magit-pre-refresh #'diff-hl-magit-pre-refresh)
  (add-hook! magit-post-refresh #'diff-hl-magit-post-refresh))
#+end_src

Small improvement to =diff-hl-show-hunk-copy-original-text=.

TODO: Contribute upstream.

#+begin_src elisp
(after! diff-hl-show-hunk
  (defun diff-hl-show-hunk-copy-original-text ()
    "Extracts all the lines from BUFFER starting with '-' to the kill ring."
    (interactive)
    (if-let (original-content diff-hl-show-hunk--original-content)
        (progn
          (kill-new original-content)
          (message "Original hunk content added to kill-ring")))
    (message "Hunk is a new addition, no content to copy."))
  nil)
#+end_src

Temporary patch to =diff-hl-show-hunk-hide= until [[https://github.com/dgutov/diff-hl/commit/d225def4a473a16ac994124e063695ef9cef3308][diff-hl@d225def4a]] is released.

#+begin_src elisp
(after! diff-hl-show-hunk
  (defun diff-hl-show-hunk-hide ()
    "Hide the current shown hunk."
    (interactive)
    (if (and diff-hl-show-hunk--original-window (window-live-p diff-hl-show-hunk--original-window))
        (select-window diff-hl-show-hunk--original-window))
    (setq diff-hl-show-hunk--original-window nil)
    (if (buffer-live-p diff-hl-show-hunk--original-buffer)
        (switch-to-buffer diff-hl-show-hunk--original-buffer))
    (setq diff-hl-show-hunk--original-buffer nil)
    (with-current-buffer (get-buffer-create diff-hl-show-hunk-buffer-name)
      (read-only-mode -1)
      (erase-buffer))
    ;; --------------------------------------------
    (when (get-buffer diff-hl-show-hunk-buffer-name)      ;; diff: check for buffer existence
      (bury-buffer diff-hl-show-hunk-buffer-name))
    (when (get-buffer diff-hl-show-hunk-diff-buffer-name) ;; diff: check for buffer existence
      (bury-buffer diff-hl-show-hunk-diff-buffer-name))
    ;; --------------------------------------------
    (when diff-hl-show-hunk--hide-function
      (let ((hidefunc diff-hl-show-hunk--hide-function))
        (setq diff-hl-show-hunk--hide-function nil)
        (funcall hidefunc)))
    (when diff-hl-show-hunk--original-overlay
      (diff-hl-show-hunk--goto-hunk-overlay diff-hl-show-hunk--original-overlay))
    (when diff-hl-show-hunk--original-overlay
      (delete-overlay diff-hl-show-hunk--original-overlay))
    (setq diff-hl-show-hunk--original-overlay nil))
  nil)
#+end_src

* dired

From the normal state, Enter dired in the CWD of the current buffer's file with =-=.

#+begin_src elisp
(map! :n "-" #'dired-jump)
#+end_src

* evil

** window navigation

Re-map keybindings to follow when splitting by default.

#+begin_src elisp
(map!
 :leader
 :desc "split below & follow"
 "w s" #'+evil/window-split-and-follow
 :desc "split below"
 "w S" #'evil-window-split
 :desc "split right & follow"
 "w v" #'+evil/window-vsplit-and-follow
 :desc "split right"
 "w V" #'evil-window-vsplit)
#+end_src

** hybrid evil/emacs keybindings

*** evil-change-back-to-indentation

Better parallels emacs's =C-k= (kill to end of line) and evil's =C= (change to end of line).

#+begin_src elisp
(defun evil-change-back-to-indentation ()
  "docstring"
  (interactive)
  (evil-delete-back-to-indentation)
  (evil-insert-state))

(map! :n  "S"   #'evil-change-back-to-indentation
      :i  "C-s" #'evil-change-back-to-indentation)
#+end_src

*** character deletion

Enable some emacs chords in evil insert state:

- =C-k= (kill to end of line)
- =C-d= (delete char)

#+begin_src elisp
(map! :i  "C-d" #'evil-delete-char
      :ni "C-k" #'evil-delete-line)
#+end_src

TODO: Fix org mode overriding these changes.

** evil-cleverparens

NB: Consider [[https://github.com/syohex/lispyville][lispyville]] as an alternative.

#+begin_src elisp
(add-hook! emacs-lisp-mode #'evil-cleverparens-mode)
#+end_src

Disable little-used keybindings likely to conflict with other packages.

#+begin_src elisp
(after! evil-cleverparens
  (map! :map evil-cleverparens-mode-map
        :n "H" nil
        :n "L" nil)
  nil)
#+end_src

** evil-unimpaired

#+begin_src elisp
(after! evil-unimpaired
  (evil-unimpaired-mode))
#+end_src

** evil-matchit

#+begin_src elisp
(after! evil-matchit
  (global-evil-matchit-mode))
#+end_src

** evil-sort

Define "inside" motion for: buffer, paragraphs, delimiters.

#+begin_src elisp
(defun evil-sort-inner (textobj &optional desc)
  "Sort inside the TEXTOBJ surrounding the point.
When DESC is non-nil, sort in descending order.
TEXTOBJ should be a symbol corresponding to `x' in the `evil-inner-x' functions."
  (interactive)
  (let ((evil-textobj (intern (format "evil-inner-%s" textobj)))
        (start-pos (point)))
    (save-excursion
      (let* ((bounds (call-interactively evil-textobj))
             (beg (first bounds))
             (end (second bounds)))
        (sort-lines desc beg end)))
    (goto-char start-pos)))

(defun evil-sort-inner-paragraph (desc)
  "Sort inside the paragraph under the point.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'paragraph desc))

(defun evil-sort-inner-buffer(desc)
  "Sort inside the current buffer.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'buffer desc))

(defun evil-sort-inner-curly(desc)
  "Sort inside the current curly braces.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'curly desc))

(defun evil-sort-inner-paren(desc)
  "Sort inside the current parentheses.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'paren desc))

(defun evil-sort-inner-bracket(desc)
  "Sort inside the current parentheses.
When called with a prefix argument DESC, sort in descending order."
  (interactive "P")
  (evil-sort-inner 'bracket desc))
#+end_src

Add sort motions to normal state map.

#+begin_src elisp
(map! :desc "sort paragraph lines" :n "g s i p" #'evil-sort-inner-paragraph
      :desc "sort buffer lines"    :n "g s i g" #'evil-sort-inner-buffer
      :desc "sort inside braces"   :n "g s i {" #'evil-sort-inner-curly
      :desc "sort inside braces"   :n "g s i }" #'evil-sort-inner-curly
      :desc "sort inside brackets" :n "g s i [" #'evil-sort-inner-bracket
      :desc "sort inside brackets" :n "g s i ]" #'evil-sort-inner-bracket
      :desc "sort inside parens"   :n "g s i (" #'evil-sort-inner-paren
      :desc "sort inside parens"   :n "g s i )" #'evil-sort-inner-paren)
#+end_src

** evil text objects

#+begin_quote
=(evil-define-text-object OBJECT (COUNT) DOC [[KEY VALUE]...] BODY...)=

Define a text object command OBJECT.

BODY should return a range (BEG END) to the right of point if COUNT is positive,
and to the left of it if negative.

Optional keyword arguments:

- =:type= - determines how the range applies after an operator
  (inclusive, line, block, and exclusive, or a self-defined
  motion type).

- =:extend-selection= - if non-nil (default), the text object always
  enlarges the current selection.  Otherwise, it replaces the current
  selection.
#+end_quote

#+begin_src elisp
(add-hook! ruby-mode #'evil-ruby-text-objects-mode)
#+end_src

* folding

Use tab to fold in prog modes.

#+begin_src elisp
(defun tab-to-fold-in-normal-state ()
  "Bind toggle-fold function to the <tab> key."
  (evil-local-set-key 'normal (kbd "<tab>") #'evil-toggle-fold))

(add-hook! prog-mode #'tab-to-fold-in-normal-state)
#+end_src

* gtags

#+begin_src elisp
(setq xref-backend-functions '(ggtags--xref-backend
                               elisp--xref-backend
                               gxref-xref-backend
                               etags--xref-backend))
#+end_src

* lookup

Lookup Dash docs quickly from the normal state.

#+begin_src elisp
(map! :n "H" #'dash-at-point)
#+end_src

Use xwidgets to browse online search results online.

#+begin_src elisp
(setq +lookup-open-url-fn #'+lookup-xwidget-webkit-open-url-fn)
#+end_src

Un-define doom's Dash-related functions since they're not installed.

TODO: Contribute upstream (check for the module inclusion flag).

#+begin_src elisp
(fmakunbound '+lookup:dash)
(fmakunbound '+lookup/in-docsets)
(fmakunbound '+lookup/in-all-docsets)
#+end_src

* lsp

#+begin_src elisp
(after! (:all company lsp-mode)
  (require 'company-lsp)
  (push 'company-lsp company-backends))

(after! lsp-mode
  (use-package lsp-ui)
  (require 'lsp-ui))
#+end_src

#+begin_src elisp
(after! lsp-ui
  (setq lsp-enable-file-watchers nil
        lsp-keymap-prefix nil
        lsp-idle-delay 0.500
        lsp-prefer-capf t
        lsp-ui-doc-alignment 'frame
        lsp-ui-doc-delay 0.2
        lsp-ui-doc-enable nil
        lsp-ui-doc-header nil
        lsp-ui-doc-include-signature t
        lsp-ui-doc-position 'at-point
        lsp-ui-doc-use-childframe t
        lsp-ui-doc-use-webkit nil
        lsp-ui-sideline-enable nil
        lsp-ui-sideline-ignore-duplicate t
        lsp-ui-sideline-show-symbol t
        read-process-output-max (* 1024 1024)))
#+end_src

* magit

#+begin_src elisp
(map! :desc "Open magit" "s-g" #'magit-status)
#+end_src

Remove the git flow hook added by doom.

#+begin_src elisp
(remove-hook! magit-mode #'turn-on-magit-gitflow)
#+end_src

* org

#+begin_src elisp
(setq org-structure-template-alist
      '(
        ("a" . "export ascii")
        ("c" . "center")
        ("C" . "comment")
        ("e" . "example")
        ("E" . "export")
        ("h" . "export html")
        ("l" . "export latex")
        ("n" . "export notes")
        ("q" . "quote")
        ("s" . "src")
        ("se" . "src elisp")
        ("sj" . "src javascript")
        ("sp" . "src python")
        ("sr" . "src ruby")
        ("sx" . "src elixir")
        ("v" . "verse")
        ))
#+end_src

* projectile

#+begin_src elisp
(map! :desc "toggle test/implementation"
      :map prog-mode-map
      :localleader
      :n "," #'projectile-toggle-between-implementation-and-test)
#+end_src

* ruby

** evil-rails

Ex commands for =projectile-rails=. Mainly here for =:AS= and =:AV=.

#+begin_src elisp
(after! projectile-rails
  (require 'evil-rails))
#+end_src

** format-all

Disable autoformatting in ruby temporarily until =rufo= is updated to format
Ruby 3's new language constructs.

#+begin_src elisp
(setq +format-on-save-enabled-modes
      '(not emacs-lisp-mode  ; elisp's mechanisms are good enough
            sql-mode         ; sqlformat is currently broken
            tex-mode         ; latexindent is broken
            latex-mode
            org-msg-edit-mode
            ruby-mode))
#+end_src

** ruby-factory

- TODO: Make =ruby-factory-switch-to-buffer= a toggle.
- TODO: Refactor to use =(after! (:all yasnippet ruby-factory))= and =add-hook!=.

#+begin_src elisp
(require 'yasnippet)
(require 'ruby-factory)
(add-hook 'ruby-mode-hook #'ruby-factory-mode)
#+end_src

** ruby-test

#+begin_src elisp
(setq
 ruby-test-rspec-options '("--backtrace" "--format progress" "--no-profile")
 ruby-test-plain-test-options '("--backtrace" "--format progress" "--no-profile")
 ruby-test-rails-test-options '("--backtrace" "--format progress" "--no-profile"))

;; Enable entering pry / irb in test runs.
(add-hook! comint-mode #'evil-normal-state #'inf-ruby-auto-enter)
#+end_src

rspec-mode options:

#+begin_src elisp
(setq
 rspec-autosave-buffer t
 rspec-command-options "--backtrace --format progress --no-profile"
 rspec-spec-command "rspec"
 rspec-use-bundler-when-possible t
 rspec-use-opts-file-when-available nil
 rspec-use-spring-when-possible nil)
#+end_src

Unbind conflicting =rspec-mode= bindings.

#+begin_src elisp
(defun unbind-rspec-keybindings ()
  "Unbind rspec-mode bindings that need to be overriden at the major mode level."
  (interactive)
  (map! :map rspec-mode-map
        :localleader
        "t l" nil
        "t t" nil))

(add-hook! rspec-mode #'unbind-rspec-keybindings)
#+end_src

Bind =ruby-test= functions.

#+begin_src elisp
(global-unset-key (kbd "s-RET"))
(global-unset-key (kbd "s-<return>"))
(global-unset-key (kbd "s-S-RET"))
(global-unset-key (kbd "s-S-<return>"))

(map! :map ruby-mode-map
      :ni "s-<return>"   #'ruby-test-run
      :ni "s-RET"        #'ruby-test-run
      :ni "s-S-<return>" #'ruby-test-run-rerun
      :ni "s-S-RET"      #'ruby-test-run-rerun)

(map! :map ruby-mode-map
      :localleader
      :n "t b" #'ruby-test-run
      :n "t l" #'ruby-test-rerun
      :n "t L" #'rspec-run-last-failed
      :n "t t" #'ruby-test-run-at-point)
#+end_src

** projectile-rails

Enable projectile-rails to find either a controller spec or request spec file as the alternate for a controller implementation file.

#+begin_src elisp
(defun rails--find-related-file (path)
  "Toggle between controller implementation at PATH and its request spec.
Look for a controller spec if there's no request spec."
  (if (string-match
       (rx (group (or "app" "spec"))
           (group "/" (or "controllers" "requests"))
           (group "/" (1+ anything))
           (group (or "_controller" "_request"))
           (group (or ".rb" "_spec.rb")))
       path)
      (let ((dir (match-string 1 path))
            (subdir (match-string 2 path))
            (file-name (match-string 3 path)))
        (let ((implementation (concat "app/controllers" file-name "_controller.rb"))
              (request-spec (concat "spec/requests" file-name "_request_spec.rb"))
              (controller-spec (concat "spec/controllers" file-name "_controller_spec.rb")))
          (if (equal dir "spec")
              (list :impl implementation)
            (list :test (if (file-exists-p (concat (projectile-project-root) request-spec))
                            request-spec
                          controller-spec)
                  :request-spec request-spec
                  :controller-spec controller-spec))))))
#+end_src

#+begin_src elisp
(after! projectile
  (projectile-register-project-type
   'ruby-rspec
   '("Gemfile")
   :compile ""
   :src-dir "lib/"
   :test "bundle exec rspec --no-profile --format progress"
   :test-dir "spec/"
   :test-suffix "_spec"
   :related-files-fn #'rails--find-related-file)

  (projectile-register-project-type
   'rails-rspec
   '("Gemfile" "app" "lib" "db" "config" "spec")
   :compile "bin/rails server"
   :src-dir "app/"
   :test "bin/rspec --no-profile --format progress"
   :test-dir "spec/"
   :test-suffix "_spec"
   :related-files-fn #'rails--find-related-file))
#+end_src

** seeing-is-believing

#+begin_src elisp
(require 'seeing-is-believing)

(setq seeing-is-believing-max-length 150
      seeing-is-believing-max-results 10
      seeing-is-believing-timeout 10.5
      seeing-is-believing-alignment 'file)

(add-hook! ruby-mode #'seeing-is-believing)

(defun xmpfilter-eval-current-line ()
  "Mark the current line for evaluation and evaluate."
  (interactive)
  (seeing-is-believing-mark-current-line-for-xmpfilter)
  (seeing-is-believing-run-as-xmpfilter))

(map! :map ruby-mode-map
      :desc "evaluate line"  "C-c C-c" #'xmpfilter-eval-current-line
      :desc "evaluate clear" "C-c C-v" #'seeing-is-believing-clear
      :desc "evaluate file"  "C-c C-f" #'seeing-is-believing-run)
#+end_src

** toggle-breakpoint

#+begin_src elisp
(defun ruby/toggle-breakpoint (&optional in-pipeline)
  "Add a break point, highlight it. Pass IN-PIPELINE to add using tap."
  (interactive "P")
  (when (eq major-mode 'ruby-mode)
    (let ((trace (cond (in-pipeline ".tap { |result| require \"pry\"; binding.pry }")
                       (t "require \"pry\"; binding.pry")))
          (line (thing-at-point 'line)))
      (if (and line (string-match trace line))
          (kill-whole-line)
        (progn
          (back-to-indentation)
          (indent-according-to-mode)
          (insert trace)
          (insert "\n")
          (indent-according-to-mode))))))

(map! :mode 'ruby-mode
      :localleader
      :n "d b" #'ruby/toggle-breakpoint
      :n "d B" #'(lambda () (interactive) (ruby/toggle-breakpoint t)))
#+end_src

* smartparens

Enable strict smartparens mode wherever smartparens is enabled.

#+begin_src elisp
(after! smartparens
  (turn-on-smartparens-strict-mode))
#+end_src

* time tracking

#+begin_src elisp
(defun magit-clock-in ()
  "Clock in with Magit, reading a commit subject line from user input."
  (interactive)
  (let ((subject-line (read-string "Task: ")))
    (magit-run-git-with-editor "clock-in" subject-line)))

(defun magit-clock-out ()
  "Clock out with Magit, opening the commit editor to finalize changes."
  (interactive)
  (magit-run-git-with-editor "clock-out-with-editor"))

(after! magit
  (transient-insert-suffix 'magit-commit "c" '("i" "Clock In" magit-clock-in))
  (transient-insert-suffix 'magit-commit "c" '("o" "Clock Out" magit-clock-out)))
#+end_src

#+begin_src elisp
(defun git-clock-in ()
  "Clock in with Git, reading a commit subject line from user input."
  (interactive)
  (when-let ((subject-line (read-string "Task: ")))
    (shell-command-to-string (format "git-clock-in %s" subject-line))))

(defun git-clock-out ()
  "Clock out with Git, committing all changed and new files in the working tree."
  (interactive)
  (shell-command-to-string (format "git add --all && git-clock-out")))

(map!
 "s-c" #'git-clock-in
 "s-C" #'git-clock-out)
#+end_src

* webkit

Reminders:

- There's a long-standing bug whereby killing a browser buffer disables =ESC= until a restart. Bury browser buffers instead.
- Use in-emacs browser sessions only for security-insensitive tasks (reading documentation, etc.)
- NB: Watching [[https://github.com/akirakyle/emacs-webkit][emacs-webkit]]

** browser-open keybindings

#+begin_src elisp
(map! :n "g F" #'browser-open-at-point)
#+end_src

** browser-open commands

#+begin_src elisp
(defun browser-open-at-point (use-new-session)
  "Open the url at the point. Use a new session if the prefix arg USE-NEW-SESSION is passed.
Prepend a scheme (https) if the address under point is missing one.
No-op if the symbol at point can't be interpreted as a URL."
  (interactive "P")
  (if-let (url (browser-open--ensure-url (browser-open--get-url-at-point)))
      (browser-open use-new-session url)
    (message (format "not a valid url"))))

(defun browser-open (new-session &optional url)
  "Open a web browser to a new url URL (prompt for it if not provided).
If prefix arg NEW-SESSION is passed, create a new session."
  (interactive "P")
  (when-let* ((hist '("http://localhost:" "https://google.com"))
              (addr (or url (read-from-minibuffer "url: " "https://" nil nil 'hist)))
              (target (unless (string= addr "") addr)))
    (progn
      (message (format "Requesting %s ..." target))
      (xwidget-webkit-browse-url target new-session)
      (switch-to-buffer (xwidget-buffer (xwidget-webkit-current-session))))))

(defun browser-open-in-new-session (&optional url)
  "Open a web browser to a new url (prompt for it) in a new session."
  (interactive)
  (browser-open t url))
#+end_src

** browser-open functions

#+begin_src elisp
(defun browser-open--ensure-url (candidate-str)
  "Ensure CANDIDATE-STR can be interpreted as a URL.
Checking for a scheme (interpolating one if missing) and a hostname with a TLD.
Return nil if the hostname is missing a TLD."
  (let* ((candidate-url (browser-open--ensure-scheme candidate-str))
         (hostname (nth 2 (split-string candidate-url "/"))))
    (when (string-match-p "\\." hostname)
      candidate-url)))

(defun browser-open--ensure-scheme (candidate-str)
  "Ensure CANDIDATE-STR is prefixed with a scheme, or return the string prepended with one"
  (if (or (string-prefix-p "https://" candidate-str t)
          (string-prefix-p "http://" candidate-str t))
    candidate-str
    (format "https://%s"
            (replace-regexp-in-string
             "^[^[:word:]]+" ""
             candidate-str))))

(defun browser-open--get-url-at-point ()
  (save-excursion
    (let* ((oldpoint (point)) (start (point)) (end (point))
           (syntaxes "w_")
           (not-syntaxes (concat "^" syntaxes)))
      (skip-syntax-backward syntaxes) (setq start (point))
      (goto-char oldpoint)
      (skip-syntax-forward syntaxes) (setq end (point))
      (when (and (eq start oldpoint)
                 (eq end oldpoint))
        ;; Look for preceding word in same line.
        (skip-syntax-backward not-syntaxes (line-beginning-position))
        (if (bolp)
            ;; No preceding word in same line.
            ;; Look for following word in same line.
            (progn
              (skip-syntax-forward not-syntaxes (line-end-position))
              (setq start (point))
              (skip-syntax-forward syntaxes)
              (setq end (point)))
          (setq end (point))
          (skip-syntax-backward syntaxes)
          (setq start (point))))
      ;; If we found something nonempty, return it as a string.
      (unless (= start end)
         (buffer-substring-no-properties start end)))))
#+end_src

** xwidget-widget keybindings

#+begin_src elisp
(defun config/xwidget-webkit ()
  "Configure xwidget keybindings."
  (evil-define-key*
    'normal xwidget-webkit-mode-map
    "g"  nil
    "G"  #'xwidget-webkit-scroll-bottom
    "J"  #'xwidget-webkit-scroll-up-line
    "K"  #'xwidget-webkit-scroll-down-line
    "gF" #'browser-open-in-new-session
    "gf" #'browser-open
    "gg" #'xwidget-webkit-scroll-top
    "h"  #'xwidget-webkit-back
    "j"  #'xwidget-webkit-scroll-up
    "k"  #'xwidget-webkit-scroll-down
    "l"  #'xwidget-webkit-forward
    "r"  #'xwidget-webkit-reload
    "y"  #'xwidget-webkit-copy-selection-as-kill
    "Y"  #'xwidget-webkit-current-url-message-kill))

(evil-set-initial-state 'xwidget-webkit-mode 'normal)
(add-hook! xwidget-webkit-mode #'config/xwidget-webkit)
#+end_src

* word chars

#+begin_src emacs-lisp
(defun add-underscore-to-word-chars ()
  "Adds underscore to the word chars syntax entry list."
  (modify-syntax-entry ?_ "w"))

(defun add-dash-to-word-chars ()
  "Adds underscore to the word chars syntax entry list."
  (modify-syntax-entry ?- "w"))

(defun config/add-to-word-char-list ()
  "Customize the word char list in prog and other modes."
  (add-hook! emacs-lisp-mode #'add-dash-to-word-chars)
  (add-hook! markdown-mode   #'add-underscore-to-word-chars)
  (add-hook! org-mode        #'add-underscore-to-word-chars)
  (add-hook! prog-mode       #'add-underscore-to-word-chars)
  (add-hook! python-mode     #'add-underscore-to-word-chars)
  (add-hook! restclient-mode #'add-underscore-to-word-chars)
  (add-hook! text-mode       #'add-underscore-to-word-chars)
  nil)

(config/add-to-word-char-list)
#+end_src

* workspaces

#+begin_src elisp
(map!
 "s-;" #'+workspace/other
 "s-{" #'+workspace/switch-left
 "s-}" #'+workspace/switch-right)
#+end_src

* yank-buffer-path-dwim

Combines behavior from the following commands, unifying their interfaces with a =C-u= fallback.:

- =+default/yank-buffer-path=
- =+default/yank-buffer-path-relative-to-project=

#+begin_src elisp
(defun is-proj-root-p (name)
  (or (file-directory-p (format "%s/.git" name))
      (file-directory-p (format "%s/.projectile" name))))

(defun yank-buffer-path-dwim (abspath-p)
  "Yank the path of the current buffer's file. (If `buffer-file-name' isn't set, use `default-directory'.)
Abbreviate the path: If in a project, relative to project root; otherwise to the tilde-abbreviated user root.
Provide an absolute path if the prefix argument ABSPATH-P is provided."
  (interactive "P")
  (let ((yanked-path
        (if-let ((file-path buffer-file-name))
            (let* ((proj-path (expand-file-name (locate-dominating-file file-path #'is-proj-root-p)))
                   (disp-path (if abspath-p file-path
                                (replace-regexp-in-string (concat "^" proj-path) "" file-path))))
              disp-path)
          (abbreviate-file-name default-directory))))
    (progn
      (kill-new yanked-path)
      (message (format "Copied to clipboard: %s" yanked-path)))))
#+end_src

#+begin_src elisp
(map! :desc "yank buffer path"
      :leader
      "f Y" nil
      "f y" #'yank-buffer-path-dwim)
#+end_src

* yankee

Set keybindings for visual mode.

TODO: Define with text objects?

#+begin_src elisp
(require 'yankee)

(map! :desc "yank with annotation"
      :nv "g y" #'yankee-yank)
#+end_src

Set parameters for =copy-as-format=.

TODO: Move into or document in yankee

#+begin_src elisp
(setq copy-as-format-asciidoc-include-file-name t
      copy-as-format-default "github")
#+end_src

* yasnippet

#+begin_src elisp
(defun yas/camelcase-file-name ()
  "Camel-case the current buffer's file name."
  (interactive)
  (let ((filename
         (file-name-nondirectory (file-name-sans-extension
                                  (or (buffer-file-name)
                                      (buffer-name (current-buffer)))))))
    (mapconcat #'capitalize (split-string filename "[_\-]") "")))

(defun yas/strip (str)
  "Extract a parameter name from STR."
  (replace-regexp-in-string ":.*$" ""
   (replace-regexp-in-string "^\s+" ""
    (replace-regexp-in-string "," ""
     str))))

(defun yas/to-field-assignment (str)
  "Make 'STR' to 'self.`STR` = `STR`'."
  (format "self.%s = %s" (yas/strip str) (yas/strip str)))

(defun yas/prepend-colon (str)
  "Make `STR' to :`STR'."
  (format ":%s" (yas/strip str)))

(defun yas/indent-level ()
  "Determine the number of spaces the current line is indented."
  (interactive)
  (string-match "[^[:space:]]" (thing-at-point 'line t)))

(defun yas/indent-string ()
  "Return a string of spaces matching the current indentation level."
  (interactive)
  (make-string (yas/indent-level) ?\s))

(defun yas/indented-newline ()
  "Newline followed by correct indentation."
  (interactive)
  (format "\n%s" (yas/indent-string)))

(defun yas/args-list ()
  "Extract an args list from the current line."
  (interactive)
  (string-match "\(.+\)" (thing-at-point 'line t)))

(defun yas/to-ruby-accessors (str)
  "Splits STR into an `attr_accesor' statement."
  (interactive)
  (mapconcat 'yas/prepend-colon (split-string str ",") ", "))

(defun yas/to-ruby-setters (str)
  "Splits STR into a sequence of field assignments."
  (interactive)
  (mapconcat 'yas/to-field-assignment
             (split-string str ",")
             (yas/indented-newline)))
#+end_src
